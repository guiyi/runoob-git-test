<p>![fig:IRKit1.jpg](https://github.com/DFRobot/DFRobotDocument/IR_Kit(SKU:DFR0107)/image/IRKit1.jpg  "IRKit1.jpg")]==Introduction==IR is widely used in remoter control. With this IR receiver, the Arduino project is able to receive command from any IR remoter controller if you have the right decoder. Well, it will be also easy to make your own IR controller using IR transmitter. ==Sample Code==</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 0.1 by pmalmsten http://www.arduino.cc/cgi-bin/yabb2/YaBB.pl?num=1176098434// 0.2 by farkinga// 0.3 by farkinga - adds cool behaviors/* 0.4 by pstrobl    changed the original program to use on IR Kit For Arduino Model: DFR0107 32 bit controller.    All keypresses are sent to the serial monitor at 9600 baud.   pulseIn is always HIGH. The phototransistor in the kit does not invert the signal.   uses pin 13 for heartbeat debug   32 bits requires a long variable, so divided up into two 15 bit so can use integer variables   use the first 15 bits of the 32 bits for remote and data stream verification. This code is always the same for every button press   use the last 15 of the 32 bits for button press selection. This code changes for each button.   ignore the middle 2 bits, it never changes.  */#define IR_BIT_LENGTH 32    // number of bits sent by IR remote#define FirstLastBit 15     // divide 32 bits into two 15 bit chunks for integer variables. Ignore center two bits. they are all the same.#define BIT_1 1500          // Binary 1 threshold (Microseconds)#define BIT_0 450           // Binary 0 threshold (Microseconds)#define BIT_START 4000      // Start bit threshold (Microseconds)#define IR_PIN 2            // IR Sensor pin#define LED_PIN 13          // LED goes off when signal is receivedint debug = 0;              // flag as 1 to output raw IR pulse data stream length in microsecondsint output_verify = 0;      // flag as 1 to print decoded verification integers. same number for all buttonsint output_key = 0;         // flag as 1 to print decoded key integersint remote_verify = 16128;  // verifies first bits are 11111100000000 different remotes may have different start codesvoid setup() {  pinMode(LED_PIN, OUTPUT);   //This shows when ready to recieve  pinMode(IR_PIN, INPUT);  digitalWrite(LED_PIN, LOW);  Serial.begin(9600);}void loop() {  digitalWrite(LED_PIN, HIGH);  int key = get_ir_key();    digitalWrite(LED_PIN, LOW);  // turn LED off while processing response  do_response(key);  delay(130);                  // 2 cycle delay to cancel duplicate keypresses}/*  wait for a keypress from the IR remote, and return the  integer mapping of that key (e.g. power button on remote returns   the integer 1429)*/int get_ir_key() {  int pulse[IR_BIT_LENGTH];  int bits[IR_BIT_LENGTH];  do {} //Wait for a start bit  while(pulseIn(IR_PIN, HIGH) &lt; BIT_START);  read_pulse(pulse);  pulse_to_bits(pulse, bits);  RemoteVerify(bits);  return bits_to_int(bits);}/*  use pulseIn to receive IR pulses from the remote.  Record the length of these pulses (in ms) in an array*/void read_pulse(int pulse[]){  for (int i = 0; i &lt; IR_BIT_LENGTH; i++)  {    pulse[i] = pulseIn(IR_PIN, HIGH);  }}/*  IR pulses encode binary &quot;0&quot; as a short pulse, and binary &quot;1&quot;  as a long pulse.  Given an array containing pulse lengths,  convert this to an array containing binary values*/void pulse_to_bits(int pulse[], int bits[]){  if (debug) { Serial.println(&quot;-----&quot;); }  for(int i = 0; i &lt; IR_BIT_LENGTH; i++)   {    if (debug) { Serial.println(pulse[i]); }    if(pulse[i] &gt; BIT_1) //is it a 1?    {      bits[i] = 1;    }      else if(pulse[i] &gt; BIT_0) //is it a 0?    {      bits[i] = 0;    }     else //data is invalid...    {      Serial.println(&quot;Error&quot;);    }  }}/*  check returns proper first 14 check bits*/void RemoteVerify(int bits[]){  int result = 0;  int seed = 1;    //Convert bits to integer  for(int i = 0 ; i &lt; (FirstLastBit) ; i++)   {           if(bits[i] == 1)     {    result += seed;    }        seed *= 2;  }        if (output_verify)      {        Serial.print(&quot;Remote &quot;);        Serial.print(result);        Serial.println(&quot; verification code&quot;);      } if (remote_verify != result) {delay (60); get_ir_key();} //verify first group of bits. delay for data stream to end, then try again.}/*  convert an array of binary values to a single base-10 integer*/int bits_to_int(int bits[]){  int result = 0;  int seed = 1;    //Convert bits to integer  for(int i = (IR_BIT_LENGTH-FirstLastBit) ; i &lt; IR_BIT_LENGTH ; i++)   {            if(bits[i] == 1)     {    result += seed;    }       seed *= 2;  }  return result;}/*   respond to specific remote-control keys with different behaviors*/void do_response(int key){      if (output_key)   {      Serial.print(&quot;Key &quot;);      Serial.println(key);   }    switch (key)  {    case 32640:  // turns on UUT power      Serial.println(&quot;POWER&quot;);      break;    case 32385:  // FUNC/STOP turns off UUT power      Serial.println(&quot;FUNC/STOP&quot;);      break;    case 32130:  // |&lt;&lt; ReTest failed Test      Serial.println(&quot;|&lt;&lt;&quot;);      break;    case 32002:  // &gt;|| Test      Serial.println(&quot;&gt;||&quot;);      break;    case 31875:  // &gt;&gt;| perform selected test number      Serial.println(&quot;&gt;&gt;|&quot;);      break;    case 32512:  // VOL+ turns on individual test beeper      Serial.println(&quot;VOL+&quot;);      break;    case 31492:  // VOL- turns off individual test beeper      Serial.println(&quot;VOL-&quot;);      break;    case 31620:  // v scroll down tests      Serial.println(&quot;v&quot;);      break;    case 31365:  // ^ scroll up tests      Serial.println(&quot;^&quot;);      break;    case 30982:  // EQ negative tests internal setup      Serial.println(&quot;EQ&quot;);      break;    case 30855:  // ST/REPT Positive tests Select Test and Repeat Test    Serial.println(&quot;ST/REPT&quot;);      break;    case 31110:  // 0      Serial.println(&quot;0&quot;);      break;    case 30600:  // 1      Serial.println(&quot;1&quot;);      break;    case 30472:  // 2      Serial.println(&quot;2&quot;);      break;    case 30345:  // 3      Serial.println(&quot;3&quot;);      break;    case 30090:  // 4      Serial.println(&quot;4&quot;);      break;    case 29962:  // 5      Serial.println(&quot;5&quot;);      break;    case 29835:  // 6      Serial.println(&quot;6&quot;);      break;    case 29580:  // 7      Serial.println(&quot;7&quot;);      break;    case 29452:  // 8      Serial.println(&quot;8&quot;);      break;    case 29325:  // 9      Serial.println(&quot;9&quot;);      break;         default:      {        Serial.print(&quot;Key &quot;);        Serial.print(key);        Serial.println(&quot; not programmed&quot;);      }    break;  }}</span></code></pre>
<p>==Trouble shooting==More question and cool idea, visit <a href="http://www.dfrobot.com/index.php?route=DFblog/blogs">DFRobot Forum</a>==More==<a href="image:nextredirectltr.png" title="wikilink">image:nextredirectltr.pngGo</a> Shopping <strong><u><a href="https://www.dfrobot.com/product-366.html">IR kit for Arduino</a></u></strong><br /><a href="image:nextredirectltr.png" title="wikilink">image:nextredirectltr.pngGo</a> Shopping <a href="http://www.dfrobot.com/index.php?route=information/distributorslogo">DFRobot Distributor List</a>Category:  <strong><u><a href="https://www.dfrobot.com/">DFRobot</a></u></strong> &gt; <strong><u><a href="https://www.dfrobot.com/category-156.html">Sensors &amp; Modules</a></u></strong>  &gt;  <strong><u><a href="https://www.dfrobot.com/category-211.html">Modules</a></u></strong> &gt; <strong><u><a href="https://www.dfrobot.com/category-212.html">IR Modules</a></u></strong><a href="category:_Product_Manual" title="wikilink">category: Product Manual</a><a href="category:_DFR_Series" title="wikilink">category: DFR Series</a><a href="category:_Robots-kits" title="wikilink">category: Robots-kits</a><a href="category:_source" title="wikilink">category: source</a></p>---
title: IR Kit(SKU:DFR0107)
permalink: /IR_Kit(SKU:DFR0107)/
---

